using Core;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Storage;
using System;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using System.ComponentModel.DataAnnotations;

namespace MMS.DAL
{
    public abstract class BaseDbContext : DbContext
    {
        public BaseDbContext(DbContextOptions options) : base(options)
        {
            ChangeTracker.QueryTrackingBehavior = QueryTrackingBehavior.NoTracking;
            AppContexts.SetActiveDbContext(this);
        }
        public virtual DbSet<AuditLog> AuditLogs { get; set; }
        public override int SaveChanges()
        {
            ValidateEntities();
            return base.SaveChanges();
            //SaveChangesWithAudit();
            //return 0;            
        }

        private void ValidateEntities()
        {
            var recordsToValidate = ChangeTracker.Entries();
            foreach (var recordToValidate in recordsToValidate)
            {
                var entity = recordToValidate.Entity;
                var validationContext = new ValidationContext(entity);
                var results = new List<ValidationResult>();
                if (!Validator.TryValidateObject(entity, validationContext, results, true))
                {
                    var messages = results.Select(r => r.ErrorMessage).ToList().Aggregate((message, nextMessage) => message + Environment.NewLine + nextMessage);
                    throw new ApplicationException($"Unable to save changes due to error(s):{Environment.NewLine}{messages}");
                }
            }
        }

        #region Audit Log

        public void SaveChangesWithAudit()
        {
            var auditEntries = OnBeforeSaveChanges();
            base.SaveChanges();
            OnAfterSaveChanges(auditEntries);
        }
        private List<AuditEntry> OnBeforeSaveChanges()
        {
            ChangeTracker.DetectChanges();
            var auditEntries = new List<AuditEntry>();
            foreach (var entry in ChangeTracker.Entries())
            {
                if (entry.Entity is AuditLog
                    || entry.State == EntityState.Detached || entry.State == EntityState.Unchanged)
                    continue;

                var logProps = entry.Entity.GetType().GetProperties().Where(
                prop => Attribute.IsDefined(prop, typeof(LoggableAttribute))).ToList();
                if (logProps.Count.IsZero()) continue;

                var auditEntry = new AuditEntry(entry)
                {
                    TableName = entry.Metadata.Relational().TableName,
                    RowState = entry.State.ToString()
                };

                var hasChange = false;
                var dbValues = entry.GetDatabaseValues();
                foreach (var property in entry.Properties)
                {
                    if (property.IsTemporary)
                    {
                        // value will be generated by the database, get the value after saving
                        auditEntry.TemporaryProperties.Add(property);
                        continue;
                    }

                    var propertyName = property.Metadata.Name;
                    if (property.Metadata.IsPrimaryKey())
                    {
                        auditEntry.KeyValues[propertyName] = property.CurrentValue;
                        continue;
                    }

                    if (logProps.FirstOrDefault(p => p.Name == propertyName).IsNull()) continue;

                    switch (entry.State)
                    {
                        case EntityState.Added:
                            hasChange = true;
                            auditEntry.NewValues[propertyName] = property.CurrentValue;
                            break;
                        case EntityState.Deleted:
                            hasChange = true;
                            auditEntry.OldValues[propertyName] = dbValues.GetValue<object>(propertyName);
                            break;
                        case EntityState.Modified:
                            var orgValue = dbValues.GetValue<object>(propertyName);
                            if (property.IsModified
                                && property.CurrentValue.NotEquals(orgValue))
                            {
                                hasChange = true;
                                auditEntry.OldValues[propertyName] = orgValue;
                                auditEntry.NewValues[propertyName] = property.CurrentValue;
                            }
                            break;
                    }
                }

                if (hasChange) auditEntries.Add(auditEntry);
            }

            // Save audit entities that have all the modifications
            foreach (var auditEntry in auditEntries.Where(p => !p.HasTemporaryProperties))
            {
                AuditLogs.Add(auditEntry.ToAudit());
            }

            // keep a list of entries where the value of some properties are unknown at this step
            return auditEntries.Where(p => p.HasTemporaryProperties).ToList();
        }

        private void OnAfterSaveChanges(List<AuditEntry> auditEntries)
        {
            if (auditEntries.IsNull() || auditEntries.Count.IsZero()) return;

            foreach (var auditEntry in auditEntries)
            {
                // Get the final value of the temporary properties
                foreach (var prop in auditEntry.TemporaryProperties)
                {
                    if (prop.Metadata.IsPrimaryKey())
                    {
                        auditEntry.KeyValues[prop.Metadata.Name] = prop.CurrentValue;
                    }
                    else
                    {
                        auditEntry.NewValues[prop.Metadata.Name] = prop.CurrentValue;
                    }
                }

                // Save the Audit entry
                AuditLogs.Add(auditEntry.ToAudit());
            }

            base.SaveChanges();
        }

        #endregion

        #region ExecuteScalar
        public T ExecuteScalar<T>(string cmdText, params object[] parameters)
        {
            try
            {
                var queryParams = new Dictionary<string, object>();
                for (var i = 0; i < parameters.Length; i++)
                {
                    queryParams.Add(i.ToString(), parameters[i]);
                }
                return ExecuteScalar<T>(cmdText, CommandType.Text, queryParams);
            }
            catch (Exception)
            {
                throw;
            }
        }
        public T ExecuteScalar<T>(string cmdText, CommandType commandType, Dictionary<string, object> parameters = null)
        {
            try
            {
                IsValidCommandText(cmdText);
                var command = Database.GetDbConnection().CreateCommand();
                if (Database.CurrentTransaction.IsNotNull())
                    command.Transaction = Database.CurrentTransaction.GetDbTransaction();
                PrepareCommand(command, commandType, cmdText);
                PrepareCommandParameter(command, parameters);
                var result = command.ExecuteScalar();
                return (T)Convert.ChangeType(result, typeof(T));
            }
            catch (Exception)
            {
                throw;
            }
        }
        private void IsValidCommandText(string commandText)
        {
            if (commandText.IsNullOrEmpty()) throw new Exception("Query is blank.");
        }
        private void PrepareCommand(IDbCommand command, CommandType commandType, string cmdText)
        {
            if (command.Connection.State == ConnectionState.Closed)
                command.Connection.Open();
            command.CommandType = commandType;
            command.CommandText = cmdText;
        }
        protected void PrepareCommandParameter(IDbCommand command, Dictionary<string, object> parameters)
        {
            if (parameters.IsNull() || parameters.Count.IsZero()) return;
            foreach (var param in parameters)
            {
                var parameter = command.CreateParameter();
                var value = param.Value;
                parameter.DbType = MappedDbType.GetDbType(value?.GetType());
                parameter.ParameterName = param.Key;
                parameter.Value = value.Value();
                command.Parameters.Add(parameter);
            }
        }
        #endregion
    }
}
